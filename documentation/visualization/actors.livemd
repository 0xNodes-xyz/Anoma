<!-- livebook:{"persist_outputs":true} -->

# The Actors

## Index

* [Index](../index_docs.livemd)
  * [Visualizing Anoma](../visualization.livemd)
    * [Actors](./actors.livemd)

## An overview of Anoma

A good overview of Actors can be seen by looking at the supervision tree of Anoma itself.

```elixir
{_, [pid1, pid2]} = Process.info(Process.whereis(:anoma), :links)
Kino.Process.render_sup_tree(pid2, direction: :left_right)
```

## Mempool

A good view of visualizing Anoma can be seen through running the
mempool, as it orchastrates the other actors in Anoma to act

<!-- livebook:{"break_markdown":true} -->

First we will create a transaction and see how that changes the base supervision tree before executing

```elixir
alias Anoma.Storage
alias Anoma.Node.Storage.Ordering
alias Anoma.Node.Mempool
alias Anoma.Node.Router
import TestHelper.Nock

storage = %Anoma.Storage{
  qualified: Anoma.Qualified,
  order: Anoma.Order
}

name = :anoma
node = Anoma.Node.state(name)
key = 555
zero = zero_counter(key)
pid_zero = Mempool.tx(node.mempool, {:kv, zero}).pid
```

<!-- livebook:{"output":true} -->

```
#PID<0.491.0>
```

The previous evaluations PID can be seen in the diagram below!

```elixir
{_, [pid1, pid2]} = Process.info(Process.whereis(:anoma), :links)
Kino.Process.render_sup_tree(pid2, direction: :left_right)
```

Now let us see what happens between the actors when we run the mempool

```elixir
Kino.Process.render_seq_trace(fn -> Mempool.execute(node.mempool) end)
```

<!-- livebook:{"output":true} -->

```
{:ok, 1}
```

As we can see, we get a fairly solid overview of what actors sent what messages

<!-- livebook:{"break_markdown":true} -->

We can also see what processes startup when we start an execution

```elixir
Kino.Process.render_seq_trace(
  [Process.whereis(node.mempool.server), Process.whereis(node.executor.server)],
  fn -> Mempool.tx(node.mempool, increment_counter_val(555)).pid() end
)
```

<!-- livebook:{"output":true} -->

```
#PID<0.495.0>
```

```elixir
{:ok, agent_pid} = Agent.start_link(fn -> [] end)
Process.monitor(agent_pid)

Kino.Process.render_seq_trace(
  agent_pid,
  fn ->
    1..2
    |> Task.async_stream(
      fn value ->
        Agent.get(agent_pid, fn value -> value end)
        100 * value
      end,
      max_concurrency: 3
    )
    |> Stream.run()

    Agent.stop(agent_pid)
  end,
  label_message: fn msg ->
    case msg do
      {:"$gen_call", _ref, {:get, atom}} ->
        {:ok, "MY CALL: #{Kino.Process.label_from_value(atom)}"}

      _ ->
        :continue
    end
  end
)
```

<!-- livebook:{"output":true} -->

```
:ok
```
